<!DOCTYPE html>
<html data-color-mode="light" data-dark-theme="dark" data-light-theme="light" lang="zh-CN">
<head>
    <meta content="text/html; charset=utf-8" http-equiv="content-type" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <link href='https://mirrors.sustech.edu.cn/cdnjs/ajax/libs/Primer/21.0.7/primer.css' rel='stylesheet' />
    <script src='https://blog.meekdai.com/Gmeek/plugins/GmeekVercount.js'></script>
    <link rel="icon" href="https://github.githubassets.com/favicons/favicon.svg"><script>
        let theme = localStorage.getItem("meek_theme") || "light";
        document.documentElement.setAttribute("data-color-mode", theme);
    </script>
<meta name="description" content="# Problem

Imagine two users try to buy the last ticket to a show at almost the same instant. Without a proper system, it's possible both users could be told they successfully bought the ticket, leading to overselling.

# Solutions

To ensure that no two users book the same ticket simultaneously, the Booking Service uses database transactions with ACID properties, employing techniques like row-level locking or optimistic concurrency control (OCC).

- **Row-Level Locking**: This is one technique to achieve isolation. When a user starts booking a ticket, the database places a 'lock' on the specific row in the database table that represents that ticket. This lock prevents any other transaction from modifying that row until the first transaction is finished (either committed or rolled back). Think of it like putting a 'reserved' sign on the ticket.

- **Optimistic Concurrency Control (OCC)**: This is an alternative to locking. Instead of locking the row, the system checks if the data has been modified by another transaction before committing the current transaction. It typically does this by comparing a version number or timestamp. If the data has changed in the meantime, the transaction is aborted, and the user might be informed that the ticket is no longer available. This is 'optimistic' because it assumes conflicts are rare.

## Row-Level Locking

Scenario: Imagine a database table storing airline seat reservations. Each row represents a seat on a specific flight.

| Flight | Seat | Customer |
|---|---|---|
| AA123 | 1A | John Doe |
| AA123 | 1B | Jane Smith |
| AA123 | 2A |  |
| AA123 | 2B |  |

Two users try to book seat 2A simultaneously:

1. User 1 clicks to book seat 2A. The database transaction begins.
2. The database places a lock on the row representing seat 2A.
3. User 2, at the exact same moment, also clicks to book seat 2A. Their transaction also begins.

However, because User 1's transaction has already locked the row, User 2's transaction is blocked. It has to wait.
User 1 completes their booking (payment goes through, etc.). The transaction commits, and the lock on seat 2A is released.

Now, User 2's transaction can proceed. But when it tries to access the row for seat 2A, it sees that it's no longer available (John Doe has it). The system informs User 2 that the seat is taken.

## Optimistic Concurrency Control (OCC)

Scenario: A similar airline seat reservation system. This time, instead of locks, each row has a version number.

| Flight | Seat | Customer | Version |
|---|---|---|---|
| AA123 | 1A | John Doe | 1 |
| AA123 | 1B | Jane Smith | 1 |
| AA123 | 2A |  | 1 |
| AA123 | 2B |  | 1 |

Two users try to book seat 2A simultaneously:

1. User 1 starts the booking process for seat 2A. The system reads the row and notes the version number (1).
2. User 2, at almost the same time, also starts booking seat 2A. Their system also reads the row and notes the version number (1).
3. User 1 completes their booking. The system checks if the version number in the database is still 1. It is, so the system updates the row with User 1's information and increments the version number to 2.
4. User 2 completes their booking a fraction of a second later. Their system also checks if the version number is still 1. But now, it's 2! This means the row has been modified by another transaction (User 1's).
5. User 2's transaction is aborted. The system informs them that the seat is no longer available.

## Key Differences

### Locking (Pessimistic):

- Locks are acquired immediately, preventing conflicts upfront.
- Can lead to performance issues if there are many concurrent users trying to access the same data (because of waiting).
- Better for situations where conflicts are likely (e.g., very popular events).

### OCC (Optimistic):

- Assumes conflicts are rare and only checks for them at the end.
- Generally better performance for most applications because there's no waiting.
- More complex to implement because you need to handle the cases where transactions are aborted.
- Both methods are used to ensure data integrity in concurrent environments, but they have different trade-offs in terms of performance and complexity.

# MySQL examples

Here are some MySQL examples demonstrating row-level locking and how it would conceptually work (MySQL doesn't directly expose OCC in the same way). I'll also explain how OCC would be implemented in SQL conceptually.

## Row-Level Locking (using FOR UPDATE)

MySQL uses FOR UPDATE to acquire exclusive row-level locks.

1. Table Setup:

```SQL
CREATE TABLE tickets (
    id INT PRIMARY KEY AUTO_INCREMENT,
    event_name VARCHAR(255),
    available_seats INT
);

INSERT INTO tickets (event_name, available_seats) VALUES ('Concert X', 10);
```

2. Booking Process (simulating two concurrent users):

- User 1 (in one MySQL session):

```SQL
START TRANSACTION; -- Start a transaction

SELECT available_seats FROM tickets WHERE id = 1 FOR UPDATE; -- Lock the row

-- Check if seats are available
SET @seats := (SELECT available_seats FROM tickets WHERE id = 1);
IF @seats > 0 THEN
    UPDATE tickets SET available_seats = available_seats - 1 WHERE id = 1;
    SELECT 'Booking successful' AS message;
    COMMIT; -- Commit the transaction, releasing the lock
ELSE
    SELECT 'No seats available' AS message;
    ROLLBACK; -- Rollback the transaction
END IF;
```

- User 2 (in a separate MySQL session, running at almost the same time):

```SQL
START TRANSACTION;

SELECT available_seats FROM tickets WHERE id = 1 FOR UPDATE; -- This will block until User 1's transaction commits

-- (Once User 1 commits, this continues)
SET @seats := (SELECT available_seats FROM tickets WHERE id = 1);
IF @seats > 0 THEN
    UPDATE tickets SET available_seats = available_seats - 1 WHERE id = 1;
    SELECT 'Booking successful' AS message;
    COMMIT;
ELSE
    SELECT 'No seats available' AS message;
    ROLLBACK;
END IF;
```

3. Explanation:

>START TRANSACTION begins a transaction.
SELECT ... FOR UPDATE acquires an exclusive lock on the selected row. This prevents other transactions from modifying the row until the current transaction is committed or rolled back.
If User 2 tries to execute the SELECT ... FOR UPDATE while User 1's transaction holds the lock, User 2's query will wait.
COMMIT makes the changes permanent and releases the lock.
ROLLBACK undoes any changes and releases the lock.

## Conceptual OCC in SQL (using a version column)

MySQL doesn't have built-in OCC like some other databases, but you can implement it yourself using a version column:

1. Table Setup (with a version column):

```SQL
ALTER TABLE tickets ADD COLUMN version INT UNSIGNED NOT NULL DEFAULT 0;
```

2. Booking Process:

```SQL
START TRANSACTION;

SELECT available_seats, version FROM tickets WHERE id = 1 INTO @seats, @version;

IF @seats > 0 THEN
    UPDATE tickets 
    SET available_seats = available_seats - 1, version = version + 1
    WHERE id = 1 AND version = @version; -- Check the version here!

    IF ROW_COUNT() > 0 THEN -- Check if the update was successful
        SELECT 'Booking successful' AS message;
        COMMIT;
    ELSE
        SELECT 'Booking failed (concurrent update)' AS message;
        ROLLBACK;
    END IF;
ELSE
    SELECT 'No seats available' AS message;
    ROLLBACK;
END IF;
```

3. Explanation of OCC Implementation:

We retrieve the available_seats and the version number in one SELECT.
The crucial part is the `WHERE id = 1 AND version = @version` clause in the UPDATE statement. This condition ensures that the update only happens if the version number in the database still matches the version number we read earlier.
ROW_COUNT() checks how many rows were affected by the UPDATE. If it's 0, it means the version has changed (another transaction modified the row), and the booking fails.

This is a simplified example. In a real application, you would need to handle the 'booking failed' case gracefully, perhaps by retrying the booking or informing the user.

These examples illustrate the core concepts of row-level locking and OCC in MySQL. They are simplified for clarity but demonstrate the key mechanisms involved. Remember that actual performance and behavior can be affected by factors like database configuration, indexes, and transaction isolation levels.

> [!NOTE]
>  The behavior of row-level locking without FOR UPDATE depends heavily on the transaction isolation level set for your MySQL session or globally for the server.
>
> - **Default Isolation Level (REPEATABLE READ)**: In MySQL's default REPEATABLE READ isolation level, a simple SELECT statement within a transaction does not acquire any locks that prevent other transactions from modifying the selected rows. This means that if you perform a SELECT and then later try to UPDATE based on the data you read, you could encounter a 'lost update' problem.
> - **READ COMMITTED Isolation Level**: In READ COMMITTED, a SELECT statement reads only committed data. However, it still doesn't acquire locks that prevent other transactions from modifying the data after the SELECT has finished. So, the lost update problem can still occur.
> - **SERIALIZABLE Isolation Level**: This is the highest isolation level. In SERIALIZABLE, even a simple SELECT statement acquires shared locks that prevent other transactions from modifying the selected rows. This prevents lost updates and other concurrency problems, but it can also significantly reduce concurrency and performance.
> - **Using FOR UPDATE (Pessimistic Locking)**: As discussed before, FOR UPDATE explicitly acquires an exclusive lock on the selected rows, regardless of the transaction isolation level (except in some very specific edge cases related to storage engines). This is the most reliable way to prevent concurrency issues like lost updates when you need to update data based on a previous read.。">
<meta property="og:title" content="Avoid double booking">
<meta property="og:description" content="# Problem

Imagine two users try to buy the last ticket to a show at almost the same instant. Without a proper system, it's possible both users could be told they successfully bought the ticket, leading to overselling.

# Solutions

To ensure that no two users book the same ticket simultaneously, the Booking Service uses database transactions with ACID properties, employing techniques like row-level locking or optimistic concurrency control (OCC).

- **Row-Level Locking**: This is one technique to achieve isolation. When a user starts booking a ticket, the database places a 'lock' on the specific row in the database table that represents that ticket. This lock prevents any other transaction from modifying that row until the first transaction is finished (either committed or rolled back). Think of it like putting a 'reserved' sign on the ticket.

- **Optimistic Concurrency Control (OCC)**: This is an alternative to locking. Instead of locking the row, the system checks if the data has been modified by another transaction before committing the current transaction. It typically does this by comparing a version number or timestamp. If the data has changed in the meantime, the transaction is aborted, and the user might be informed that the ticket is no longer available. This is 'optimistic' because it assumes conflicts are rare.

## Row-Level Locking

Scenario: Imagine a database table storing airline seat reservations. Each row represents a seat on a specific flight.

| Flight | Seat | Customer |
|---|---|---|
| AA123 | 1A | John Doe |
| AA123 | 1B | Jane Smith |
| AA123 | 2A |  |
| AA123 | 2B |  |

Two users try to book seat 2A simultaneously:

1. User 1 clicks to book seat 2A. The database transaction begins.
2. The database places a lock on the row representing seat 2A.
3. User 2, at the exact same moment, also clicks to book seat 2A. Their transaction also begins.

However, because User 1's transaction has already locked the row, User 2's transaction is blocked. It has to wait.
User 1 completes their booking (payment goes through, etc.). The transaction commits, and the lock on seat 2A is released.

Now, User 2's transaction can proceed. But when it tries to access the row for seat 2A, it sees that it's no longer available (John Doe has it). The system informs User 2 that the seat is taken.

## Optimistic Concurrency Control (OCC)

Scenario: A similar airline seat reservation system. This time, instead of locks, each row has a version number.

| Flight | Seat | Customer | Version |
|---|---|---|---|
| AA123 | 1A | John Doe | 1 |
| AA123 | 1B | Jane Smith | 1 |
| AA123 | 2A |  | 1 |
| AA123 | 2B |  | 1 |

Two users try to book seat 2A simultaneously:

1. User 1 starts the booking process for seat 2A. The system reads the row and notes the version number (1).
2. User 2, at almost the same time, also starts booking seat 2A. Their system also reads the row and notes the version number (1).
3. User 1 completes their booking. The system checks if the version number in the database is still 1. It is, so the system updates the row with User 1's information and increments the version number to 2.
4. User 2 completes their booking a fraction of a second later. Their system also checks if the version number is still 1. But now, it's 2! This means the row has been modified by another transaction (User 1's).
5. User 2's transaction is aborted. The system informs them that the seat is no longer available.

## Key Differences

### Locking (Pessimistic):

- Locks are acquired immediately, preventing conflicts upfront.
- Can lead to performance issues if there are many concurrent users trying to access the same data (because of waiting).
- Better for situations where conflicts are likely (e.g., very popular events).

### OCC (Optimistic):

- Assumes conflicts are rare and only checks for them at the end.
- Generally better performance for most applications because there's no waiting.
- More complex to implement because you need to handle the cases where transactions are aborted.
- Both methods are used to ensure data integrity in concurrent environments, but they have different trade-offs in terms of performance and complexity.

# MySQL examples

Here are some MySQL examples demonstrating row-level locking and how it would conceptually work (MySQL doesn't directly expose OCC in the same way). I'll also explain how OCC would be implemented in SQL conceptually.

## Row-Level Locking (using FOR UPDATE)

MySQL uses FOR UPDATE to acquire exclusive row-level locks.

1. Table Setup:

```SQL
CREATE TABLE tickets (
    id INT PRIMARY KEY AUTO_INCREMENT,
    event_name VARCHAR(255),
    available_seats INT
);

INSERT INTO tickets (event_name, available_seats) VALUES ('Concert X', 10);
```

2. Booking Process (simulating two concurrent users):

- User 1 (in one MySQL session):

```SQL
START TRANSACTION; -- Start a transaction

SELECT available_seats FROM tickets WHERE id = 1 FOR UPDATE; -- Lock the row

-- Check if seats are available
SET @seats := (SELECT available_seats FROM tickets WHERE id = 1);
IF @seats > 0 THEN
    UPDATE tickets SET available_seats = available_seats - 1 WHERE id = 1;
    SELECT 'Booking successful' AS message;
    COMMIT; -- Commit the transaction, releasing the lock
ELSE
    SELECT 'No seats available' AS message;
    ROLLBACK; -- Rollback the transaction
END IF;
```

- User 2 (in a separate MySQL session, running at almost the same time):

```SQL
START TRANSACTION;

SELECT available_seats FROM tickets WHERE id = 1 FOR UPDATE; -- This will block until User 1's transaction commits

-- (Once User 1 commits, this continues)
SET @seats := (SELECT available_seats FROM tickets WHERE id = 1);
IF @seats > 0 THEN
    UPDATE tickets SET available_seats = available_seats - 1 WHERE id = 1;
    SELECT 'Booking successful' AS message;
    COMMIT;
ELSE
    SELECT 'No seats available' AS message;
    ROLLBACK;
END IF;
```

3. Explanation:

>START TRANSACTION begins a transaction.
SELECT ... FOR UPDATE acquires an exclusive lock on the selected row. This prevents other transactions from modifying the row until the current transaction is committed or rolled back.
If User 2 tries to execute the SELECT ... FOR UPDATE while User 1's transaction holds the lock, User 2's query will wait.
COMMIT makes the changes permanent and releases the lock.
ROLLBACK undoes any changes and releases the lock.

## Conceptual OCC in SQL (using a version column)

MySQL doesn't have built-in OCC like some other databases, but you can implement it yourself using a version column:

1. Table Setup (with a version column):

```SQL
ALTER TABLE tickets ADD COLUMN version INT UNSIGNED NOT NULL DEFAULT 0;
```

2. Booking Process:

```SQL
START TRANSACTION;

SELECT available_seats, version FROM tickets WHERE id = 1 INTO @seats, @version;

IF @seats > 0 THEN
    UPDATE tickets 
    SET available_seats = available_seats - 1, version = version + 1
    WHERE id = 1 AND version = @version; -- Check the version here!

    IF ROW_COUNT() > 0 THEN -- Check if the update was successful
        SELECT 'Booking successful' AS message;
        COMMIT;
    ELSE
        SELECT 'Booking failed (concurrent update)' AS message;
        ROLLBACK;
    END IF;
ELSE
    SELECT 'No seats available' AS message;
    ROLLBACK;
END IF;
```

3. Explanation of OCC Implementation:

We retrieve the available_seats and the version number in one SELECT.
The crucial part is the `WHERE id = 1 AND version = @version` clause in the UPDATE statement. This condition ensures that the update only happens if the version number in the database still matches the version number we read earlier.
ROW_COUNT() checks how many rows were affected by the UPDATE. If it's 0, it means the version has changed (another transaction modified the row), and the booking fails.

This is a simplified example. In a real application, you would need to handle the 'booking failed' case gracefully, perhaps by retrying the booking or informing the user.

These examples illustrate the core concepts of row-level locking and OCC in MySQL. They are simplified for clarity but demonstrate the key mechanisms involved. Remember that actual performance and behavior can be affected by factors like database configuration, indexes, and transaction isolation levels.

> [!NOTE]
>  The behavior of row-level locking without FOR UPDATE depends heavily on the transaction isolation level set for your MySQL session or globally for the server.
>
> - **Default Isolation Level (REPEATABLE READ)**: In MySQL's default REPEATABLE READ isolation level, a simple SELECT statement within a transaction does not acquire any locks that prevent other transactions from modifying the selected rows. This means that if you perform a SELECT and then later try to UPDATE based on the data you read, you could encounter a 'lost update' problem.
> - **READ COMMITTED Isolation Level**: In READ COMMITTED, a SELECT statement reads only committed data. However, it still doesn't acquire locks that prevent other transactions from modifying the data after the SELECT has finished. So, the lost update problem can still occur.
> - **SERIALIZABLE Isolation Level**: This is the highest isolation level. In SERIALIZABLE, even a simple SELECT statement acquires shared locks that prevent other transactions from modifying the selected rows. This prevents lost updates and other concurrency problems, but it can also significantly reduce concurrency and performance.
> - **Using FOR UPDATE (Pessimistic Locking)**: As discussed before, FOR UPDATE explicitly acquires an exclusive lock on the selected rows, regardless of the transaction isolation level (except in some very specific edge cases related to storage engines). This is the most reliable way to prevent concurrency issues like lost updates when you need to update data based on a previous read.。">
<meta property="og:type" content="article">
<meta property="og:url" content="https://leadtechinterview.github.io/post/Avoid%20double%20booking.html">
<meta property="og:image" content="https://github.githubassets.com/favicons/favicon.svg">
<title>Avoid double booking</title>
<link href="//unpkg.com/@wooorm/starry-night@2.1.1/style/both.css" rel="stylesheet" />


</head>
<style>
body{box-sizing: border-box;min-width: 200px;max-width: 900px;margin: 20px auto;padding: 45px;font-size: 16px;font-family: sans-serif;line-height: 1.25;}
#header{display:flex;padding-bottom:8px;border-bottom: 1px solid var(--borderColor-muted, var(--color-border-muted));margin-bottom: 16px;}
#footer {margin-top:64px; text-align: center;font-size: small;}

</style>

<style>
.postTitle{margin: auto 0;font-size:40px;font-weight:bold;}
.title-right{display:flex;margin:auto 0 0 auto;}
.title-right .circle{padding: 14px 16px;margin-right:8px;}
#postBody{border-bottom: 1px solid var(--color-border-default);padding-bottom:36px;}
#postBody hr{height:2px;}
#cmButton{height:48px;margin-top:48px;}
#comments{margin-top:64px;}
.g-emoji{font-size:24px;}
@media (max-width: 600px) {
    body {padding: 8px;}
    .postTitle{font-size:24px;}
}
.copy-feedback {
    display: none;
    position: absolute;
    top: 10px;
    right: 50px;
    color: var(--color-fg-on-emphasis);
    background-color: var(--color-fg-muted);
    border-radius: 3px;
    padding: 5px 8px;
    font-size: 12px;
}
</style>
<style>.markdown-alert{padding:0.5rem 1rem;margin-bottom:1rem;border-left:.25em solid var(--borderColor-default,var(--color-border-default));}.markdown-alert .markdown-alert-title {display:flex;font-weight:var(--base-text-weight-medium,500);align-items:center;line-height:1;}.markdown-alert>:first-child {margin-top:0;}.markdown-alert>:last-child {margin-bottom:0;}</style><style>.markdown-alert.markdown-alert-note {border-left-color:var(--borderColor-accent-emphasis, var(--color-accent-emphasis));background-color:var(--color-accent-subtle);}.markdown-alert.markdown-alert-note .markdown-alert-title {color: var(--fgColor-accent,var(--color-accent-fg));}</style>



<body>
    <div id="header">
<h1 class="postTitle">Avoid double booking</h1>
<div class="title-right">
    <a href="https://leadtechinterview.github.io" id="buttonHome" class="btn btn-invisible circle" title="首页">
        <svg class="octicon" width="16" height="16">
            <path id="pathHome" fill-rule="evenodd"></path>
        </svg>
    </a>
    
    <a href="https://github.com/LeadTechInterview/leadtechinterview.github.io/issues/4" target="_blank" class="btn btn-invisible circle" title="Issue">
        <svg class="octicon" width="16" height="16">
            <path id="pathIssue" fill-rule="evenodd"></path>
        </svg>
    </a>
    

    <a class="btn btn-invisible circle" onclick="modeSwitch();" title="切换主题">
        <svg class="octicon" width="16" height="16" >
            <path id="themeSwitch" fill-rule="evenodd"></path>
        </svg>
    </a>

</div>
</div>
    <div id="content">
<div class="markdown-body" id="postBody"><h1>Problem</h1>
<p>Imagine two users try to buy the last ticket to a show at almost the same instant. Without a proper system, it's possible both users could be told they successfully bought the ticket, leading to overselling.</p>
<h1>Solutions</h1>
<p>To ensure that no two users book the same ticket simultaneously, the Booking Service uses database transactions with ACID properties, employing techniques like row-level locking or optimistic concurrency control (OCC).</p>
<ul>
<li>
<p><strong>Row-Level Locking</strong>: This is one technique to achieve isolation. When a user starts booking a ticket, the database places a "lock" on the specific row in the database table that represents that ticket. This lock prevents any other transaction from modifying that row until the first transaction is finished (either committed or rolled back). Think of it like putting a "reserved" sign on the ticket.</p>
</li>
<li>
<p><strong>Optimistic Concurrency Control (OCC)</strong>: This is an alternative to locking. Instead of locking the row, the system checks if the data has been modified by another transaction before committing the current transaction. It typically does this by comparing a version number or timestamp. If the data has changed in the meantime, the transaction is aborted, and the user might be informed that the ticket is no longer available. This is "optimistic" because it assumes conflicts are rare.</p>
</li>
</ul>
<h2>Row-Level Locking</h2>
<p>Scenario: Imagine a database table storing airline seat reservations. Each row represents a seat on a specific flight.</p>
<markdown-accessiblity-table><table role="table">
<thead>
<tr>
<th>Flight</th>
<th>Seat</th>
<th>Customer</th>
</tr>
</thead>
<tbody>
<tr>
<td>AA123</td>
<td>1A</td>
<td>John Doe</td>
</tr>
<tr>
<td>AA123</td>
<td>1B</td>
<td>Jane Smith</td>
</tr>
<tr>
<td>AA123</td>
<td>2A</td>
<td></td>
</tr>
<tr>
<td>AA123</td>
<td>2B</td>
<td></td>
</tr>
</tbody>
</table></markdown-accessiblity-table>
<p>Two users try to book seat 2A simultaneously:</p>
<ol>
<li>User 1 clicks to book seat 2A. The database transaction begins.</li>
<li>The database places a lock on the row representing seat 2A.</li>
<li>User 2, at the exact same moment, also clicks to book seat 2A. Their transaction also begins.</li>
</ol>
<p>However, because User 1's transaction has already locked the row, User 2's transaction is blocked. It has to wait.<br>
User 1 completes their booking (payment goes through, etc.). The transaction commits, and the lock on seat 2A is released.</p>
<p>Now, User 2's transaction can proceed. But when it tries to access the row for seat 2A, it sees that it's no longer available (John Doe has it). The system informs User 2 that the seat is taken.</p>
<h2>Optimistic Concurrency Control (OCC)</h2>
<p>Scenario: A similar airline seat reservation system. This time, instead of locks, each row has a version number.</p>
<markdown-accessiblity-table><table role="table">
<thead>
<tr>
<th>Flight</th>
<th>Seat</th>
<th>Customer</th>
<th>Version</th>
</tr>
</thead>
<tbody>
<tr>
<td>AA123</td>
<td>1A</td>
<td>John Doe</td>
<td>1</td>
</tr>
<tr>
<td>AA123</td>
<td>1B</td>
<td>Jane Smith</td>
<td>1</td>
</tr>
<tr>
<td>AA123</td>
<td>2A</td>
<td></td>
<td>1</td>
</tr>
<tr>
<td>AA123</td>
<td>2B</td>
<td></td>
<td>1</td>
</tr>
</tbody>
</table></markdown-accessiblity-table>
<p>Two users try to book seat 2A simultaneously:</p>
<ol>
<li>User 1 starts the booking process for seat 2A. The system reads the row and notes the version number (1).</li>
<li>User 2, at almost the same time, also starts booking seat 2A. Their system also reads the row and notes the version number (1).</li>
<li>User 1 completes their booking. The system checks if the version number in the database is still 1. It is, so the system updates the row with User 1's information and increments the version number to 2.</li>
<li>User 2 completes their booking a fraction of a second later. Their system also checks if the version number is still 1. But now, it's 2! This means the row has been modified by another transaction (User 1's).</li>
<li>User 2's transaction is aborted. The system informs them that the seat is no longer available.</li>
</ol>
<h2>Key Differences</h2>
<h3>Locking (Pessimistic):</h3>
<ul>
<li>Locks are acquired immediately, preventing conflicts upfront.</li>
<li>Can lead to performance issues if there are many concurrent users trying to access the same data (because of waiting).</li>
<li>Better for situations where conflicts are likely (e.g., very popular events).</li>
</ul>
<h3>OCC (Optimistic):</h3>
<ul>
<li>Assumes conflicts are rare and only checks for them at the end.</li>
<li>Generally better performance for most applications because there's no waiting.</li>
<li>More complex to implement because you need to handle the cases where transactions are aborted.</li>
<li>Both methods are used to ensure data integrity in concurrent environments, but they have different trade-offs in terms of performance and complexity.</li>
</ul>
<h1>MySQL examples</h1>
<p>Here are some MySQL examples demonstrating row-level locking and how it would conceptually work (MySQL doesn't directly expose OCC in the same way). I'll also explain how OCC would be implemented in SQL conceptually.</p>
<h2>Row-Level Locking (using FOR UPDATE)</h2>
<p>MySQL uses FOR UPDATE to acquire exclusive row-level locks.</p>
<ol>
<li>Table Setup:</li>
</ol>
<div class="highlight highlight-source-sql"><pre class="notranslate"><span class="pl-k">CREATE</span> <span class="pl-k">TABLE</span> <span class="pl-en">tickets</span> (
    id <span class="pl-k">INT</span> <span class="pl-k">PRIMARY KEY</span> AUTO_INCREMENT,
    event_name <span class="pl-k">VARCHAR</span>(<span class="pl-c1">255</span>),
    available_seats <span class="pl-k">INT</span>
);

<span class="pl-k">INSERT INTO</span> tickets (event_name, available_seats) <span class="pl-k">VALUES</span> (<span class="pl-s"><span class="pl-pds">'</span>Concert X<span class="pl-pds">'</span></span>, <span class="pl-c1">10</span>);</pre></div>
<ol start="2">
<li>Booking Process (simulating two concurrent users):</li>
</ol>
<ul>
<li>User 1 (in one MySQL session):</li>
</ul>
<div class="highlight highlight-source-sql"><pre class="notranslate"><span class="pl-k">START TRANSACTION</span>; <span class="pl-c"><span class="pl-c">--</span> Start a transaction</span>

<span class="pl-k">SELECT</span> available_seats <span class="pl-k">FROM</span> tickets <span class="pl-k">WHERE</span> id <span class="pl-k">=</span> <span class="pl-c1">1</span> FOR <span class="pl-k">UPDATE</span>; <span class="pl-c"><span class="pl-c">--</span> Lock the row</span>

<span class="pl-c"><span class="pl-c">--</span> Check if seats are available</span>
<span class="pl-k">SET</span> @seats :<span class="pl-k">=</span> (<span class="pl-k">SELECT</span> available_seats <span class="pl-k">FROM</span> tickets <span class="pl-k">WHERE</span> id <span class="pl-k">=</span> <span class="pl-c1">1</span>);
IF @seats <span class="pl-k">&gt;</span> <span class="pl-c1">0</span> THEN
    <span class="pl-k">UPDATE</span> tickets <span class="pl-k">SET</span> available_seats <span class="pl-k">=</span> available_seats <span class="pl-k">-</span> <span class="pl-c1">1</span> <span class="pl-k">WHERE</span> id <span class="pl-k">=</span> <span class="pl-c1">1</span>;
    <span class="pl-k">SELECT</span> <span class="pl-s"><span class="pl-pds">'</span>Booking successful<span class="pl-pds">'</span></span> <span class="pl-k">AS</span> message;
    <span class="pl-k">COMMIT</span>; <span class="pl-c"><span class="pl-c">--</span> Commit the transaction, releasing the lock</span>
ELSE
    <span class="pl-k">SELECT</span> <span class="pl-s"><span class="pl-pds">'</span>No seats available<span class="pl-pds">'</span></span> <span class="pl-k">AS</span> message;
    <span class="pl-k">ROLLBACK</span>; <span class="pl-c"><span class="pl-c">--</span> Rollback the transaction</span>
END IF;</pre></div>
<ul>
<li>User 2 (in a separate MySQL session, running at almost the same time):</li>
</ul>
<div class="highlight highlight-source-sql"><pre class="notranslate"><span class="pl-k">START TRANSACTION</span>;

<span class="pl-k">SELECT</span> available_seats <span class="pl-k">FROM</span> tickets <span class="pl-k">WHERE</span> id <span class="pl-k">=</span> <span class="pl-c1">1</span> FOR <span class="pl-k">UPDATE</span>; <span class="pl-c"><span class="pl-c">--</span> This will block until User 1's transaction commits</span>

<span class="pl-c"><span class="pl-c">--</span> (Once User 1 commits, this continues)</span>
<span class="pl-k">SET</span> @seats :<span class="pl-k">=</span> (<span class="pl-k">SELECT</span> available_seats <span class="pl-k">FROM</span> tickets <span class="pl-k">WHERE</span> id <span class="pl-k">=</span> <span class="pl-c1">1</span>);
IF @seats <span class="pl-k">&gt;</span> <span class="pl-c1">0</span> THEN
    <span class="pl-k">UPDATE</span> tickets <span class="pl-k">SET</span> available_seats <span class="pl-k">=</span> available_seats <span class="pl-k">-</span> <span class="pl-c1">1</span> <span class="pl-k">WHERE</span> id <span class="pl-k">=</span> <span class="pl-c1">1</span>;
    <span class="pl-k">SELECT</span> <span class="pl-s"><span class="pl-pds">'</span>Booking successful<span class="pl-pds">'</span></span> <span class="pl-k">AS</span> message;
    <span class="pl-k">COMMIT</span>;
ELSE
    <span class="pl-k">SELECT</span> <span class="pl-s"><span class="pl-pds">'</span>No seats available<span class="pl-pds">'</span></span> <span class="pl-k">AS</span> message;
    <span class="pl-k">ROLLBACK</span>;
END IF;</pre></div>
<ol start="3">
<li>Explanation:</li>
</ol>
<blockquote>
<p>START TRANSACTION begins a transaction.<br>
SELECT ... FOR UPDATE acquires an exclusive lock on the selected row. This prevents other transactions from modifying the row until the current transaction is committed or rolled back.<br>
If User 2 tries to execute the SELECT ... FOR UPDATE while User 1's transaction holds the lock, User 2's query will wait.<br>
COMMIT makes the changes permanent and releases the lock.<br>
ROLLBACK undoes any changes and releases the lock.</p>
</blockquote>
<h2>Conceptual OCC in SQL (using a version column)</h2>
<p>MySQL doesn't have built-in OCC like some other databases, but you can implement it yourself using a version column:</p>
<ol>
<li>Table Setup (with a version column):</li>
</ol>
<div class="highlight highlight-source-sql"><pre class="notranslate"><span class="pl-k">ALTER</span> <span class="pl-k">TABLE</span> tickets ADD COLUMN version <span class="pl-k">INT</span> UNSIGNED <span class="pl-k">NOT NULL</span> DEFAULT <span class="pl-c1">0</span>;</pre></div>
<ol start="2">
<li>Booking Process:</li>
</ol>
<div class="highlight highlight-source-sql"><pre class="notranslate"><span class="pl-k">START TRANSACTION</span>;

<span class="pl-k">SELECT</span> available_seats, version <span class="pl-k">FROM</span> tickets <span class="pl-k">WHERE</span> id <span class="pl-k">=</span> <span class="pl-c1">1</span> INTO @seats, @version;

IF @seats <span class="pl-k">&gt;</span> <span class="pl-c1">0</span> THEN
    <span class="pl-k">UPDATE</span> tickets 
    <span class="pl-k">SET</span> available_seats <span class="pl-k">=</span> available_seats <span class="pl-k">-</span> <span class="pl-c1">1</span>, version <span class="pl-k">=</span> version <span class="pl-k">+</span> <span class="pl-c1">1</span>
    <span class="pl-k">WHERE</span> id <span class="pl-k">=</span> <span class="pl-c1">1</span> <span class="pl-k">AND</span> version <span class="pl-k">=</span> @version; <span class="pl-c"><span class="pl-c">--</span> Check the version here!</span>

    IF ROW_COUNT() <span class="pl-k">&gt;</span> <span class="pl-c1">0</span> THEN <span class="pl-c"><span class="pl-c">--</span> Check if the update was successful</span>
        <span class="pl-k">SELECT</span> <span class="pl-s"><span class="pl-pds">'</span>Booking successful<span class="pl-pds">'</span></span> <span class="pl-k">AS</span> message;
        <span class="pl-k">COMMIT</span>;
    ELSE
        <span class="pl-k">SELECT</span> <span class="pl-s"><span class="pl-pds">'</span>Booking failed (concurrent update)<span class="pl-pds">'</span></span> <span class="pl-k">AS</span> message;
        <span class="pl-k">ROLLBACK</span>;
    END IF;
ELSE
    <span class="pl-k">SELECT</span> <span class="pl-s"><span class="pl-pds">'</span>No seats available<span class="pl-pds">'</span></span> <span class="pl-k">AS</span> message;
    <span class="pl-k">ROLLBACK</span>;
END IF;</pre></div>
<ol start="3">
<li>Explanation of OCC Implementation:</li>
</ol>
<p>We retrieve the available_seats and the version number in one SELECT.<br>
The crucial part is the <code class="notranslate">WHERE id = 1 AND version = @version</code> clause in the UPDATE statement. This condition ensures that the update only happens if the version number in the database still matches the version number we read earlier.<br>
ROW_COUNT() checks how many rows were affected by the UPDATE. If it's 0, it means the version has changed (another transaction modified the row), and the booking fails.</p>
<p>This is a simplified example. In a real application, you would need to handle the "booking failed" case gracefully, perhaps by retrying the booking or informing the user.</p>
<p>These examples illustrate the core concepts of row-level locking and OCC in MySQL. They are simplified for clarity but demonstrate the key mechanisms involved. Remember that actual performance and behavior can be affected by factors like database configuration, indexes, and transaction isolation levels.</p>
<div class="markdown-alert markdown-alert-note"><p class="markdown-alert-title"><svg class="octicon octicon-info mr-2" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg>Note</p><p>The behavior of row-level locking without FOR UPDATE depends heavily on the transaction isolation level set for your MySQL session or globally for the server.</p>
<ul>
<li><strong>Default Isolation Level (REPEATABLE READ)</strong>: In MySQL's default REPEATABLE READ isolation level, a simple SELECT statement within a transaction does not acquire any locks that prevent other transactions from modifying the selected rows. This means that if you perform a SELECT and then later try to UPDATE based on the data you read, you could encounter a "lost update" problem.</li>
<li><strong>READ COMMITTED Isolation Level</strong>: In READ COMMITTED, a SELECT statement reads only committed data. However, it still doesn't acquire locks that prevent other transactions from modifying the data after the SELECT has finished. So, the lost update problem can still occur.</li>
<li><strong>SERIALIZABLE Isolation Level</strong>: This is the highest isolation level. In SERIALIZABLE, even a simple SELECT statement acquires shared locks that prevent other transactions from modifying the selected rows. This prevents lost updates and other concurrency problems, but it can also significantly reduce concurrency and performance.</li>
<li><strong>Using FOR UPDATE (Pessimistic Locking)</strong>: As discussed before, FOR UPDATE explicitly acquires an exclusive lock on the selected rows, regardless of the transaction isolation level (except in some very specific edge cases related to storage engines). This is the most reliable way to prevent concurrency issues like lost updates when you need to update data based on a previous read.</li>
</ul>
</div></div>
<div style="font-size:small;margin-top:8px;float:right;"></div>

<button class="btn btn-block" type="button" onclick="openComments()" id="cmButton">评论</button>
<div class="comments" id="comments"></div>

</div>
    <div id="footer"><div id="footer1">Copyright © <span id="copyrightYear"></span> <a href="https://leadtechinterview.github.io">Lead Tech Interview</a></div>
<div id="footer2">
    <span id="runday"></span><span>Powered by <a href="https://meekdai.com/Gmeek.html" target="_blank">Gmeek</a></span>
</div>

<script>
var now=new Date();
document.getElementById("copyrightYear").innerHTML=now.getFullYear();

if(""!=""){
    var startSite=new Date("");
    var diff=now.getTime()-startSite.getTime();
    var diffDay=Math.floor(diff/(1000*60*60*24));
    document.getElementById("runday").innerHTML="网站运行"+diffDay+"天"+" • ";
}
</script></div>
</body>
<script>
var IconList={'sun': 'M8 10.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5zM8 12a4 4 0 100-8 4 4 0 000 8zM8 0a.75.75 0 01.75.75v1.5a.75.75 0 01-1.5 0V.75A.75.75 0 018 0zm0 13a.75.75 0 01.75.75v1.5a.75.75 0 01-1.5 0v-1.5A.75.75 0 018 13zM2.343 2.343a.75.75 0 011.061 0l1.06 1.061a.75.75 0 01-1.06 1.06l-1.06-1.06a.75.75 0 010-1.06zm9.193 9.193a.75.75 0 011.06 0l1.061 1.06a.75.75 0 01-1.06 1.061l-1.061-1.06a.75.75 0 010-1.061zM16 8a.75.75 0 01-.75.75h-1.5a.75.75 0 010-1.5h1.5A.75.75 0 0116 8zM3 8a.75.75 0 01-.75.75H.75a.75.75 0 010-1.5h1.5A.75.75 0 013 8zm10.657-5.657a.75.75 0 010 1.061l-1.061 1.06a.75.75 0 11-1.06-1.06l1.06-1.06a.75.75 0 011.06 0zm-9.193 9.193a.75.75 0 010 1.06l-1.06 1.061a.75.75 0 11-1.061-1.06l1.06-1.061a.75.75 0 011.061 0z', 'moon': 'M9.598 1.591a.75.75 0 01.785-.175 7 7 0 11-8.967 8.967.75.75 0 01.961-.96 5.5 5.5 0 007.046-7.046.75.75 0 01.175-.786zm1.616 1.945a7 7 0 01-7.678 7.678 5.5 5.5 0 107.678-7.678z', 'sync': 'M1.705 8.005a.75.75 0 0 1 .834.656 5.5 5.5 0 0 0 9.592 2.97l-1.204-1.204a.25.25 0 0 1 .177-.427h3.646a.25.25 0 0 1 .25.25v3.646a.25.25 0 0 1-.427.177l-1.38-1.38A7.002 7.002 0 0 1 1.05 8.84a.75.75 0 0 1 .656-.834ZM8 2.5a5.487 5.487 0 0 0-4.131 1.869l1.204 1.204A.25.25 0 0 1 4.896 6H1.25A.25.25 0 0 1 1 5.75V2.104a.25.25 0 0 1 .427-.177l1.38 1.38A7.002 7.002 0 0 1 14.95 7.16a.75.75 0 0 1-1.49.178A5.5 5.5 0 0 0 8 2.5Z', 'home': 'M6.906.664a1.749 1.749 0 0 1 2.187 0l5.25 4.2c.415.332.657.835.657 1.367v7.019A1.75 1.75 0 0 1 13.25 15h-3.5a.75.75 0 0 1-.75-.75V9H7v5.25a.75.75 0 0 1-.75.75h-3.5A1.75 1.75 0 0 1 1 13.25V6.23c0-.531.242-1.034.657-1.366l5.25-4.2Zm1.25 1.171a.25.25 0 0 0-.312 0l-5.25 4.2a.25.25 0 0 0-.094.196v7.019c0 .138.112.25.25.25H5.5V8.25a.75.75 0 0 1 .75-.75h3.5a.75.75 0 0 1 .75.75v5.25h2.75a.25.25 0 0 0 .25-.25V6.23a.25.25 0 0 0-.094-.195Z', 'github': 'M8 0c4.42 0 8 3.58 8 8a8.013 8.013 0 0 1-5.45 7.59c-.4.08-.55-.17-.55-.38 0-.27.01-1.13.01-2.2 0-.75-.25-1.23-.54-1.48 1.78-.2 3.65-.88 3.65-3.95 0-.88-.31-1.59-.82-2.15.08-.2.36-1.02-.08-2.12 0 0-.67-.22-2.2.82-.64-.18-1.32-.27-2-.27-.68 0-1.36.09-2 .27-1.53-1.03-2.2-.82-2.2-.82-.44 1.1-.16 1.92-.08 2.12-.51.56-.82 1.28-.82 2.15 0 3.06 1.86 3.75 3.64 3.95-.23.2-.44.55-.51 1.07-.46.21-1.61.55-2.33-.66-.15-.24-.6-.83-1.23-.82-.67.01-.27.38.01.53.34.19.73.9.82 1.13.16.45.68 1.31 2.69.94 0 .67.01 1.3.01 1.49 0 .21-.15.45-.55.38A7.995 7.995 0 0 1 0 8c0-4.42 3.58-8 8-8Z', 'copy': 'M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 0 1 0 1.5h-1.5a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-1.5a.75.75 0 0 1 1.5 0v1.5A1.75 1.75 0 0 1 9.25 16h-7.5A1.75 1.75 0 0 1 0 14.25Z M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0 1 14.25 11h-7.5A1.75 1.75 0 0 1 5 9.25Zm1.75-.25a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-7.5a.25.25 0 0 0-.25-.25Z', 'check': 'M13.78 4.22a.75.75 0 0 1 0 1.06l-7.25 7.25a.75.75 0 0 1-1.06 0L2.22 9.28a.751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018L6 10.94l6.72-6.72a.75.75 0 0 1 1.06 0Z'};
var utterancesLoad=0;

let themeSettings={
    "dark": ["dark","moon","#00f0ff","dark-blue"],
    "light": ["light","sun","#ff5000","github-light"],
    "auto": ["auto","sync","","preferred-color-scheme"]
};
function changeTheme(mode, icon, color, utheme){
    document.documentElement.setAttribute("data-color-mode",mode);
    document.getElementById("themeSwitch").setAttribute("d",value=IconList[icon]);
    document.getElementById("themeSwitch").parentNode.style.color=color;
    if(utterancesLoad==1){utterancesTheme(utheme);}
}
function modeSwitch(){
    let currentMode=document.documentElement.getAttribute('data-color-mode');
    let newMode = currentMode === "light" ? "dark" : currentMode === "dark" ? "auto" : "light";
    localStorage.setItem("meek_theme", newMode);
    if(themeSettings[newMode]){
        changeTheme(...themeSettings[newMode]);
    }
}
function utterancesTheme(theme){
    const message={type:'set-theme',theme: theme};
    const iframe=document.getElementsByClassName('utterances-frame')[0];
    iframe.contentWindow.postMessage(message,'https://utteranc.es');
}
if(themeSettings[theme]){changeTheme(...themeSettings[theme]);}
console.log("\n %c Gmeek last https://github.com/Meekdai/Gmeek \n","padding:5px 0;background:#02d81d;color:#fff");
</script>

<script>
document.getElementById("pathHome").setAttribute("d",IconList["home"]);
document.getElementById("pathIssue").setAttribute("d",IconList["github"]);



function openComments(){
    cm=document.getElementById("comments");
    cmButton=document.getElementById("cmButton");
    cmButton.innerHTML="loading";
    span=document.createElement("span");
    span.setAttribute("class","AnimatedEllipsis");
    cmButton.appendChild(span);

    script=document.createElement("script");
    script.setAttribute("src","https://utteranc.es/client.js");
    script.setAttribute("repo","LeadTechInterview/leadtechinterview.github.io");
    script.setAttribute("issue-term","title");
    
    if(localStorage.getItem("meek_theme")=="dark"){script.setAttribute("theme","dark-blue");}
    else if(localStorage.getItem("meek_theme")=="light") {script.setAttribute("theme","github-light");}
    else{script.setAttribute("theme","preferred-color-scheme");}
    
    script.setAttribute("crossorigin","anonymous");
    script.setAttribute("async","");
    cm.appendChild(script);

    int=self.setInterval("iFrameLoading()",200);
}

function iFrameLoading(){
    var utterances=document.getElementsByClassName('utterances');
    if(utterances.length==1){
        if(utterances[0].style.height!=""){
            utterancesLoad=1;
            int=window.clearInterval(int);
            document.getElementById("cmButton").style.display="none";
            console.log("utterances Load OK");
        }
    }
}

document.addEventListener('DOMContentLoaded', () => {
    const createClipboardHTML = (codeContent, additionalClasses = '') => `
        <pre class="notranslate"><code class="notranslate">${codeContent}</code></pre>
        <div class="clipboard-container position-absolute right-0 top-0 ${additionalClasses}">
            <clipboard-copy class="ClipboardButton btn m-2 p-0" role="button" style="display: inherit;">
                <svg height="16" width="16" class="octicon octicon-copy m-2"><path d="${IconList["copy"]}"></path></svg>
                <svg height="16" width="16" class="octicon octicon-check color-fg-success m-2 d-none"><path d="${IconList["check"]}"></path></svg>
            </clipboard-copy>
            <div class="copy-feedback">Copied!</div>
        </div>
    `;

    const handleCodeElements = (selector = '') => {
        document.querySelectorAll(selector).forEach(codeElement => {
            const codeContent = codeElement.innerHTML;
            const newStructure = document.createElement('div');
            newStructure.className = 'snippet-clipboard-content position-relative overflow-auto';
            newStructure.innerHTML = createClipboardHTML(codeContent);

            const parentElement = codeElement.parentElement;
            if (selector.includes('highlight')) {
                parentElement.insertBefore(newStructure, codeElement.nextSibling);
                parentElement.removeChild(codeElement);
            } else {
                parentElement.parentElement.replaceChild(newStructure, parentElement);
            }
        });
    };

    handleCodeElements('pre.notranslate > code.notranslate');
    handleCodeElements('div.highlight > pre.notranslate');

    let currentFeedback = null;
    document.querySelectorAll('clipboard-copy').forEach(copyButton => {
        copyButton.addEventListener('click', () => {
            const codeContent = copyButton.closest('.snippet-clipboard-content').innerText;
            const tempTextArea = document.createElement('textarea');
            tempTextArea.value = codeContent;
            document.body.appendChild(tempTextArea);
            tempTextArea.select();
            document.execCommand('copy');
            document.body.removeChild(tempTextArea);

            const copyIcon = copyButton.querySelector('.octicon-copy');
            const checkIcon = copyButton.querySelector('.octicon-check');
            const copyFeedback = copyButton.nextElementSibling;

            if (currentFeedback && currentFeedback !== copyFeedback) {currentFeedback.style.display = 'none';}
            currentFeedback = copyFeedback;

            copyIcon.classList.add('d-none');
            checkIcon.classList.remove('d-none');
            copyFeedback.style.display = 'block';
            copyButton.style.borderColor = 'var(--color-success-fg)';

            setTimeout(() => {
                copyIcon.classList.remove('d-none');
                checkIcon.classList.add('d-none');
                copyFeedback.style.display = 'none';
                copyButton.style.borderColor = '';
            }, 2000);
        });
    });
});

</script>
<script src='https://blog.meekdai.com/Gmeek/plugins/GmeekTOC.js'></script>

</html>
